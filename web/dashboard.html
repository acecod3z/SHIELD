<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHIELD Defense Systems - Threat Analysis Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-blue: #0d1b2a;
            --secondary-blue: #1b263b;
            --accent-cyan: #00d4ff;
            --accent-green: #00ff88;
            --accent-orange: #ff6b35;
            --text-light: #e0e1dd;
            --text-dark: #0d1b2a;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: #000000;
            color: var(--text-light);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* Letter Glitch Background */
        #glitchCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
        }

        .outer-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,1) 100%);
            z-index: -1;
        }

        /* Header */
        .header {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--glass-border);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-green));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 1.5rem;
            color: var(--primary-blue);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .logo-text {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1.8rem;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Gooey Navigation Styles */
        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
            position: relative;
        }

        .gooey-nav-container {
            position: relative;
            display: flex;
            gap: 0;
        }

        .gooey-nav-container nav ul {
            list-style: none;
            display: flex;
            gap: 0;
            margin: 0;
            padding: 0;
            position: relative;
            z-index: 2;
        }

        .gooey-nav-container nav ul li {
            margin: 0;
        }

        .nav-link {
            color: var(--text-light);
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-size: 0.9rem;
            display: block;
            position: relative;
            z-index: 2;
            transition: color 0.3s ease;
        }

        .gooey-nav-container nav ul li.active .nav-link {
            color: var(--primary-blue);
        }

        .nav-link:hover {
            color: var(--accent-cyan);
        }

        /* Gooey Effect Elements */
        .effect {
            position: absolute;
            pointer-events: none;
            z-index: 1;
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .effect.filter {
            background: var(--accent-cyan);
            border-radius: 8px;
            filter: url(#gooey);
        }

        .effect.text {
            color: var(--primary-blue);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .effect.text.active {
            opacity: 1;
        }

        /* Particles */
        .particle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            pointer-events: none;
            transform: translate(
                var(--start-x, 0),
                var(--start-y, 0)
            ) scale(0);
            animation: particle-move var(--time, 1200ms) ease-out forwards;
        }

        .particle .point {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--color, var(--accent-cyan));
            transform: translate(-50%, -50%) scale(var(--scale, 1));
            filter: blur(2px);
        }

        @keyframes particle-move {
            0% {
                transform: translate(var(--start-x, 0), var(--start-y, 0)) 
                           scale(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(var(--end-x, 0), var(--end-y, 0)) 
                           scale(var(--scale, 1)) 
                           rotate(var(--rotate, 360deg));
                opacity: 0;
            }
        }

        .effect.filter.active .particle {
            animation: particle-move var(--time, 1200ms) ease-out forwards;
        }

        /* Color variants for particles */
        :root {
            --color-1: #00d4ff;
            --color-2: #00ff88;
            --color-3: #0099ff;
            --color-4: #00ffcc;
        }

        /* Main container */
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .dashboard-header {
            text-align: center;
            margin-bottom: 2rem;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 20px;
            padding: 2rem 3rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .dashboard-title {
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .dashboard-subtitle {
            font-size: 1.5rem;
            color: #ffffff;
            opacity: 1;
            font-weight: 500;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        /* Dashboard grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .dashboard-card {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .dashboard-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
        }

        .card-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: var(--accent-cyan);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-green);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-light);
            opacity: 0.8;
        }

        /* Threat analysis report */
        .threat-report {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }

        .threat-report::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
        }

        .report-header {
            text-align: center;
            margin-bottom: 2rem;
            font-family: 'Orbitron', monospace;
        }

        .report-title {
            font-size: 1.8rem;
            color: var(--accent-cyan);
            margin-bottom: 0.5rem;
        }

        .report-id {
            font-size: 0.9rem;
            color: rgba(224, 225, 221, 0.7);
        }

        /* Threat status */
        .threat-status {
            padding: 1.5rem;
            border-radius: 15px;
            margin: 1.5rem 0;
            text-align: center;
            font-weight: 600;
            font-size: 1.2rem;
            position: relative;
        }

        .threat-status.benign {
            background: linear-gradient(45deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
            border: 2px solid var(--accent-green);
            color: var(--accent-green);
        }

        .threat-status.malicious {
            background: linear-gradient(45deg, rgba(255, 107, 53, 0.3), rgba(255, 107, 53, 0.1));
            border: 2px solid var(--accent-orange);
            color: var(--accent-orange);
            animation: warningPulse 2s infinite;
        }

        @keyframes warningPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 107, 53, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 107, 53, 0.6); }
        }

        .confidence, .threat-level {
            font-size: 1rem;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        /* Metadata section */
        .metadata-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
        }

        .metadata-title {
            color: var(--accent-cyan);
            font-family: 'Orbitron', monospace;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .metadata-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        .metadata-item:last-child {
            border-bottom: none;
        }

        /* Activity log */
        .activity-log {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1.5rem;
            max-height: 400px;
            overflow-y: auto;
            position: relative;
            scroll-behavior: smooth;
        }

        .activity-log::-webkit-scrollbar {
            width: 8px;
        }

        .activity-log::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .activity-log::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 10px;
        }

        .log-entry {
            padding: 0.8rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--accent-cyan);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.7);
            animation: fadeInScale 0.3s ease forwards;
        }

        @keyframes fadeInScale {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .log-entry:nth-child(1) { animation-delay: 0.05s; }
        .log-entry:nth-child(2) { animation-delay: 0.1s; }
        .log-entry:nth-child(3) { animation-delay: 0.15s; }
        .log-entry:nth-child(4) { animation-delay: 0.2s; }
        .log-entry:nth-child(5) { animation-delay: 0.25s; }
        .log-entry:nth-child(6) { animation-delay: 0.3s; }
        .log-entry:nth-child(7) { animation-delay: 0.35s; }
        .log-entry:nth-child(8) { animation-delay: 0.4s; }

        .log-entry:hover,
        .log-entry.selected {
            background: rgba(0, 212, 255, 0.15);
            transform: scale(1.02);
            border-left-color: var(--accent-green);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .log-entry.selected {
            border-left-width: 4px;
        }

        .log-time {
            color: var(--accent-cyan);
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .log-entry:hover .log-time,
        .log-entry.selected .log-time {
            color: var(--accent-green);
        }

        .log-action {
            color: var(--text-light);
            margin-top: 0.2rem;
        }

        .activity-gradient-top,
        .activity-gradient-bottom {
            position: absolute;
            left: 0;
            right: 0;
            height: 50px;
            pointer-events: none;
            opacity: 0;
            z-index: 1;
        }

        .activity-gradient-top {
            top: 0;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
            transition: opacity 0.2s ease;
        }

        .activity-gradient-bottom {
            bottom: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            transition: opacity 0.1s ease;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 0 1rem;
            }
            
            .threat-report {
                padding: 1.5rem;
            }
            
            .header-content {
                padding: 0 1rem;
            }
            
            .nav-menu {
                gap: 1rem;
            }
            
            .dashboard-title {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Letter Glitch Background -->
    <canvas id="glitchCanvas"></canvas>
    <div class="outer-vignette"></div>

    <!-- SVG Filter for Gooey Effect -->
    <svg style="position: absolute; width: 0; height: 0;">
        <defs>
            <filter id="gooey">
                <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
                <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10" result="gooey" />
                <feComposite in="SourceGraphic" in2="gooey" operator="atop"/>
            </filter>
        </defs>
    </svg>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">S</div>
                <div class="logo-text">SHIELD</div>
            </div>
            <nav class="nav-menu">
                <div class="gooey-nav-container" id="gooeyNav">
                    <nav>
                        <ul>
                            <li>
                                <a href="index.html" class="nav-link">Threat Scanner</a>
                            </li>
                            <li class="active">
                                <a href="dashboard.html" class="nav-link">Dashboard</a>
                            </li>
                        </ul>
                    </nav>
                    <span class="effect filter"></span>
                    <span class="effect text"></span>
                </div>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <!-- Dashboard Header -->
        <div class="dashboard-header">
            <h1 class="dashboard-title">THREAT ANALYSIS DASHBOARD</h1>
            <p class="dashboard-subtitle">Real-time Security Intelligence & Monitoring</p>
        </div>

        <!-- Latest Threat Analysis Report -->
        <div class="threat-report">
            <div class="report-header">
                <h3 class="report-title">Threat Analysis Report</h3>
                <div class="report-id">Analysis ID: analysis_f16109965_19590012 | System: SHIELD-AI</div>
            </div>

            <!-- Threat Status -->
            <div class="threat-status benign">
                <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üõ°Ô∏è ‚úÖ SECURE</div>
                <div class="confidence">Confidence Level: 100.0%</div>
                <div class="threat-level">Classification: LOW</div>
            </div>

            <!-- System Diagnostics -->
            <div class="metadata-section">
                <h4 class="metadata-title">üìä System Diagnostics</h4>
                <div class="metadata-item">
                    <span>Processing Time:</span>
                    <span>136.99 ms</span>
                </div>
                <div class="metadata-item">
                    <span>Analysis Timestamp:</span>
                    <span>10/30/2025, 1:07:46 PM</span>
                </div>
                <div class="metadata-item">
                    <span>User IP Address:</span>
                    <span id="userIp">Detecting...</span>
                </div>
            </div>

            <!-- Detected Threats Details (only shown if malicious) -->
            <div class="metadata-section" id="threatsDetails" style="display: none;">
                <h4 class="metadata-title">‚ö†Ô∏è Detected Threats</h4>
                <div id="threatsContainer">
                    <!-- Threats will be populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Activity Log -->
        <div class="dashboard-grid">
            <div class="dashboard-card">
                <h3 class="card-title">üìà Recent Activity</h3>
                <div class="activity-log" id="recentActivity">
                    <div class="activity-gradient-top"></div>
                    <div class="log-entry" data-index="0">
                        <div class="log-time">13:07:46</div>
                        <div class="log-action">Threat scan completed - SECURE</div>
                    </div>
                    <div class="log-entry" data-index="1">
                        <div class="log-time">13:05:22</div>
                        <div class="log-action">SQL injection attempt detected and blocked</div>
                    </div>
                    <div class="log-entry" data-index="2">
                        <div class="log-time">12:58:11</div>
                        <div class="log-action">System diagnostics completed</div>
                    </div>
                    <div class="log-entry" data-index="3">
                        <div class="log-time">12:45:33</div>
                        <div class="log-action">Database integrity check passed</div>
                    </div>
                    <div class="log-entry" data-index="4">
                        <div class="log-time">12:30:15</div>
                        <div class="log-action">AI model updated to v1.0.0</div>
                    </div>
                    <div class="log-entry" data-index="5">
                        <div class="log-time">12:15:42</div>
                        <div class="log-action">Firewall rules updated</div>
                    </div>
                    <div class="log-entry" data-index="6">
                        <div class="log-time">12:00:00</div>
                        <div class="log-action">Daily security report generated</div>
                    </div>
                    <div class="activity-gradient-bottom"></div>
                </div>
            </div>
            <div class="dashboard-card">
                <h3 class="card-title">üéØ Threat Categories</h3>
                <div class="activity-log" id="threatCategories">
                    <div class="activity-gradient-top"></div>
                    <div class="log-entry" data-index="0">
                        <div class="log-time">SQL Injection</div>
                        <div class="log-action">67 attempts blocked</div>
                    </div>
                    <div class="log-entry" data-index="1">
                        <div class="log-time">XSS Attacks</div>
                        <div class="log-action">34 attempts blocked</div>
                    </div>
                    <div class="log-entry" data-index="2">
                        <div class="log-time">Command Injection</div>
                        <div class="log-action">23 attempts blocked</div>
                    </div>
                    <div class="log-entry" data-index="3">
                        <div class="log-time">CSRF Attacks</div>
                        <div class="log-action">19 attempts blocked</div>
                    </div>
                    <div class="log-entry" data-index="4">
                        <div class="log-time">Path Traversal</div>
                        <div class="log-action">12 attempts blocked</div>
                    </div>
                    <div class="log-entry" data-index="5">
                        <div class="log-time">SSRF</div>
                        <div class="log-action">8 attempts blocked</div>
                    </div>
                    <div class="activity-gradient-bottom"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Gooey Navigation Class
        class GooeyNav {
            constructor(container, options = {}) {
                this.container = container;
                this.nav = container.querySelector('nav ul');
                this.filterEffect = container.querySelector('.effect.filter');
                this.textEffect = container.querySelector('.effect.text');
                
                this.options = {
                    animationTime: options.animationTime || 600,
                    particleCount: options.particleCount || 15,
                    particleDistances: options.particleDistances || [90, 10],
                    particleR: options.particleR || 100,
                    timeVariance: options.timeVariance || 300,
                    colors: options.colors || [1, 2, 3, 1, 2, 3, 1, 4]
                };

                this.activeIndex = 0;
                this.init();
            }

            noise(n = 1) {
                return n / 2 - Math.random() * n;
            }

            getXY(distance, pointIndex, totalPoints) {
                const angle = ((360 + this.noise(8)) / totalPoints) * pointIndex * (Math.PI / 180);
                return [distance * Math.cos(angle), distance * Math.sin(angle)];
            }

            createParticle(i, t, d, r) {
                const rotate = this.noise(r / 10);
                return {
                    start: this.getXY(d[0], this.options.particleCount - i, this.options.particleCount),
                    end: this.getXY(d[1] + this.noise(7), this.options.particleCount - i, this.options.particleCount),
                    time: t,
                    scale: 1 + this.noise(0.2),
                    color: this.options.colors[Math.floor(Math.random() * this.options.colors.length)],
                    rotate: rotate > 0 ? (rotate + r / 20) * 10 : (rotate - r / 20) * 10
                };
            }

            makeParticles(element) {
                const d = this.options.particleDistances;
                const r = this.options.particleR;
                const bubbleTime = this.options.animationTime * 2 + this.options.timeVariance;
                element.style.setProperty('--time', `${bubbleTime}ms`);

                for (let i = 0; i < this.options.particleCount; i++) {
                    const t = this.options.animationTime * 2 + this.noise(this.options.timeVariance * 2);
                    const p = this.createParticle(i, t, d, r);
                    element.classList.remove('active');

                    setTimeout(() => {
                        const particle = document.createElement('span');
                        const point = document.createElement('span');
                        particle.classList.add('particle');
                        particle.style.setProperty('--start-x', `${p.start[0]}px`);
                        particle.style.setProperty('--start-y', `${p.start[1]}px`);
                        particle.style.setProperty('--end-x', `${p.end[0]}px`);
                        particle.style.setProperty('--end-y', `${p.end[1]}px`);
                        particle.style.setProperty('--time', `${p.time}ms`);
                        particle.style.setProperty('--scale', `${p.scale}`);
                        particle.style.setProperty('--color', `var(--color-${p.color}, #00d4ff)`);
                        particle.style.setProperty('--rotate', `${p.rotate}deg`);

                        point.classList.add('point');
                        particle.appendChild(point);
                        element.appendChild(particle);
                        
                        requestAnimationFrame(() => {
                            element.classList.add('active');
                        });
                        
                        setTimeout(() => {
                            try {
                                element.removeChild(particle);
                            } catch (e) {
                                // Particle already removed
                            }
                        }, t);
                    }, 30);
                }
            }

            updateEffectPosition(element) {
                if (!this.container || !this.filterEffect || !this.textEffect) return;
                const containerRect = this.container.getBoundingClientRect();
                const pos = element.getBoundingClientRect();

                const styles = {
                    left: `${pos.x - containerRect.x}px`,
                    top: `${pos.y - containerRect.y}px`,
                    width: `${pos.width}px`,
                    height: `${pos.height}px`
                };
                
                Object.assign(this.filterEffect.style, styles);
                Object.assign(this.textEffect.style, styles);
                this.textEffect.innerText = element.innerText;
            }

            handleClick(e, index) {
                e.preventDefault();
                const liEl = e.currentTarget.parentElement;
                if (this.activeIndex === index) {
                    // Still navigate on active click
                    window.location.href = e.currentTarget.href;
                    return;
                }

                // Update active state
                this.nav.querySelectorAll('li').forEach((li, i) => {
                    li.classList.toggle('active', i === index);
                });
                
                this.activeIndex = index;
                this.updateEffectPosition(liEl);

                // Clear old particles
                if (this.filterEffect) {
                    const particles = this.filterEffect.querySelectorAll('.particle');
                    particles.forEach(p => this.filterEffect.removeChild(p));
                }

                // Animate text
                if (this.textEffect) {
                    this.textEffect.classList.remove('active');
                    void this.textEffect.offsetWidth; // Force reflow
                    this.textEffect.classList.add('active');
                }

                // Create particles
                if (this.filterEffect) {
                    this.makeParticles(this.filterEffect);
                }

                // Navigate after animation
                setTimeout(() => {
                    window.location.href = e.currentTarget.href;
                }, 400);
            }

            init() {
                const links = this.nav.querySelectorAll('a');
                links.forEach((link, index) => {
                    link.addEventListener('click', (e) => this.handleClick(e, index));
                });

                // Set initial position
                const activeLi = this.nav.querySelectorAll('li')[this.activeIndex];
                if (activeLi) {
                    this.updateEffectPosition(activeLi);
                    this.textEffect.classList.add('active');
                }

                // Handle resize
                const resizeObserver = new ResizeObserver(() => {
                    const currentActiveLi = this.nav.querySelectorAll('li')[this.activeIndex];
                    if (currentActiveLi) {
                        this.updateEffectPosition(currentActiveLi);
                    }
                });

                resizeObserver.observe(this.container);
            }
        }

        // Animated List Functionality
        function initAnimatedList(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const entries = container.querySelectorAll('.log-entry');
            const topGradient = container.querySelector('.activity-gradient-top');
            const bottomGradient = container.querySelector('.activity-gradient-bottom');
            let selectedIndex = -1;

            // Handle scroll gradients
            const handleScroll = () => {
                const { scrollTop, scrollHeight, clientHeight } = container;
                if (topGradient) {
                    topGradient.style.opacity = Math.min(scrollTop / 50, 1);
                }
                if (bottomGradient) {
                    const bottomDistance = scrollHeight - (scrollTop + clientHeight);
                    // Hide instantly when at bottom (within 5px threshold)
                    if (bottomDistance <= 5) {
                        bottomGradient.style.opacity = 0;
                    } else if (scrollHeight <= clientHeight) {
                        bottomGradient.style.opacity = 0;
                    } else {
                        bottomGradient.style.opacity = Math.min(bottomDistance / 50, 1);
                    }
                }
            };

            container.addEventListener('scroll', handleScroll);
            handleScroll(); // Initial check

            // Mouse hover selection
            entries.forEach((entry, index) => {
                entry.addEventListener('mouseenter', () => {
                    entries.forEach(e => e.classList.remove('selected'));
                    entry.classList.add('selected');
                    selectedIndex = index;
                });

                entry.addEventListener('click', () => {
                    console.log(`Selected: ${entry.querySelector('.log-time').textContent}`);
                });
            });

            // Keyboard navigation
            const handleKeyDown = (e) => {
                if (!container.contains(document.activeElement) && selectedIndex === -1) return;

                if (e.key === 'ArrowDown' || (e.key === 'Tab' && !e.shiftKey)) {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, entries.length - 1);
                    updateSelection();
                } else if (e.key === 'ArrowUp' || (e.key === 'Tab' && e.shiftKey)) {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    updateSelection();
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    entries[selectedIndex].click();
                }
            };

            const updateSelection = () => {
                entries.forEach((entry, index) => {
                    entry.classList.toggle('selected', index === selectedIndex);
                });

                if (selectedIndex >= 0 && entries[selectedIndex]) {
                    const selectedEntry = entries[selectedIndex];
                    const containerRect = container.getBoundingClientRect();
                    const entryRect = selectedEntry.getBoundingClientRect();
                    
                    const extraMargin = 50;
                    if (entryRect.top < containerRect.top + extraMargin) {
                        container.scrollTo({
                            top: selectedEntry.offsetTop - extraMargin,
                            behavior: 'smooth'
                        });
                    } else if (entryRect.bottom > containerRect.bottom - extraMargin) {
                        container.scrollTo({
                            top: selectedEntry.offsetTop - container.clientHeight + selectedEntry.offsetHeight + extraMargin,
                            behavior: 'smooth'
                        });
                    }
                }
            };

            window.addEventListener('keydown', handleKeyDown);

            // Make container focusable
            container.setAttribute('tabindex', '0');
            container.addEventListener('focus', () => {
                if (selectedIndex === -1) {
                    selectedIndex = 0;
                    updateSelection();
                }
            });
        }

        // Initialize both animated lists
        initAnimatedList('recentActivity');
        initAnimatedList('threatCategories');

        // Decrypted Text Animation
        class DecryptedText {
            constructor(element, options = {}) {
                this.element = element;
                this.originalText = element.textContent;
                this.speed = options.speed || 50;
                this.maxIterations = options.maxIterations || 10;
                this.characters = options.characters || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
                this.isAnimating = false;
                this.currentIteration = 0;
                this.interval = null;
                
                this.animate();
            }
            
            getRandomChar() {
                return this.characters[Math.floor(Math.random() * this.characters.length)];
            }
            
            animate() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                this.currentIteration = 0;
                
                this.interval = setInterval(() => {
                    let displayText = '';
                    const revealLength = Math.floor((this.currentIteration / this.maxIterations) * this.originalText.length);
                    
                    for (let i = 0; i < this.originalText.length; i++) {
                        if (this.originalText[i] === ' ') {
                            displayText += ' ';
                        } else if (i < revealLength) {
                            displayText += this.originalText[i];
                        } else {
                            displayText += this.getRandomChar();
                        }
                    }
                    
                    this.element.textContent = displayText;
                    this.currentIteration++;
                    
                    if (this.currentIteration >= this.maxIterations) {
                        clearInterval(this.interval);
                        this.element.textContent = this.originalText;
                        this.isAnimating = false;
                    }
                }, this.speed);
            }
        }
        
        // Animate dashboard headings on page load
        setTimeout(() => {
            const dashboardTitle = document.querySelector('.dashboard-title');
            if (dashboardTitle) {
                new DecryptedText(dashboardTitle, { speed: 30, maxIterations: 20 });
            }
            
            const reportTitle = document.querySelector('.report-title');
            if (reportTitle) {
                setTimeout(() => {
                    new DecryptedText(reportTitle, { speed: 40, maxIterations: 15 });
                }, 300);
            }
        }, 100);

        // Auto-refresh dashboard every 30 seconds
        setInterval(() => {
            console.log('Dashboard refreshing...');
            loadLatestAnalysis();
        }, 30000);

        // Load latest analysis from localStorage
        function loadLatestAnalysis() {
            const latestAnalysis = localStorage.getItem('latestThreatAnalysis');
            if (latestAnalysis) {
                try {
                    const analysisData = JSON.parse(latestAnalysis);
                    updateThreatReport(analysisData);
                } catch (e) {
                    console.error('Error parsing analysis data:', e);
                }
            }
        }

        // Update threat report with new data
        function updateThreatReport(data) {
            const reportId = document.querySelector('.report-id');
            const threatStatus = document.querySelector('.threat-status');
            const metadataItems = document.querySelectorAll('.metadata-item span:last-child');

            if (reportId && data.job_id) {
                reportId.textContent = `Analysis ID: ${data.job_id} | System: SHIELD-AI`;
            }

            if (threatStatus && data.result) {
                const result = data.result;
                const statusClass = result.is_malicious ? 'malicious' : 'benign';
                const statusText = result.is_malicious ? 'üö® THREAT DETECTED' : 'üõ°Ô∏è ‚úÖ SECURE';
                
                threatStatus.className = `threat-status ${statusClass}`;
                threatStatus.innerHTML = `
                    <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">${statusText}</div>
                    <div class="confidence">Confidence Level: ${(result.confidence_score * 100).toFixed(1)}%</div>
                    <div class="threat-level">Classification: ${result.threat_level.toUpperCase()}</div>
                `;

                // Show/hide threat details section
                const threatsDetails = document.getElementById('threatsDetails');
                const threatsContainer = document.getElementById('threatsContainer');
                
                if (result.is_malicious && result.detected_threats && result.detected_threats.length > 0) {
                    threatsDetails.style.display = 'block';
                    threatsContainer.innerHTML = '';
                    
                    result.detected_threats.forEach((threat, index) => {
                        const threatCard = document.createElement('div');
                        threatCard.style.cssText = `
                            background: rgba(255, 0, 0, 0.05);
                            border: 1px solid rgba(255, 0, 0, 0.3);
                            border-radius: 8px;
                            padding: 1rem;
                            margin-bottom: 1rem;
                        `;
                        
                        threatCard.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <div style="font-weight: bold; color: #ff0066; font-size: 1.1rem;">
                                    ${threat.attack_type?.replace(/_/g, ' ').toUpperCase() || 'UNKNOWN THREAT'}
                                </div>
                                <div style="background: rgba(255, 0, 0, 0.2); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.9rem;">
                                    ${threat.severity?.toUpperCase() || 'MEDIUM'}
                                </div>
                            </div>
                            <div style="color: rgba(255, 255, 255, 0.8); margin-bottom: 0.5rem;">
                                ${threat.description || 'Potential security threat detected'}
                            </div>
                            <div style="display: flex; gap: 2rem; font-size: 0.9rem; color: rgba(255, 255, 255, 0.6);">
                                <div>
                                    <span style="color: rgba(255, 255, 255, 0.5);">Confidence:</span> 
                                    <span style="color: #ff6600;">${(threat.confidence * 100).toFixed(1)}%</span>
                                </div>
                                ${threat.mitigation ? `
                                <div>
                                    <span style="color: rgba(255, 255, 255, 0.5);">Mitigation:</span> 
                                    <span style="color: #00ff88;">${threat.mitigation}</span>
                                </div>
                                ` : ''}
                            </div>
                        `;
                        
                        threatsContainer.appendChild(threatCard);
                    });
                } else {
                    threatsDetails.style.display = 'none';
                }
            }

            // Update metadata
            if (metadataItems.length >= 4 && data.result) {
                metadataItems[0].textContent = `${data.result.processing_time_ms?.toFixed(2) || 'N/A'} ms`;
                metadataItems[1].textContent = data.result.ai_model_version || 'SHIELD-Defense-v1.0';
                metadataItems[2].textContent = new Date(data.timestamp || Date.now()).toLocaleString();
                metadataItems[3].textContent = 'Military Grade Encryption';
            }

            // Add to activity log
            addToActivityLog(data);
        }

        // Add entry to activity log
        function addToActivityLog(data) {
            const activityLog = document.querySelector('.activity-log');
            if (activityLog && data.result) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                const time = new Date().toLocaleTimeString();
                const action = data.result.is_malicious ? 
                    `${data.result.detected_threats?.[0]?.attack_type?.replace(/_/g, ' ') || 'Threat'} detected and analyzed` :
                    'Threat scan completed - SECURE';
                
                logEntry.innerHTML = `
                    <div class="log-time">${time}</div>
                    <div class="log-action">${action}</div>
                `;
                
                // Insert at the top
                activityLog.insertBefore(logEntry, activityLog.firstChild);
                
                // Keep only last 5 entries
                while (activityLog.children.length > 5) {
                    activityLog.removeChild(activityLog.lastChild);
                }
            }
        }

        // Function to get and display user IP
        async function displayUserIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                
                // Update the IP display element
                const ipElement = document.getElementById('userIp');
                if (ipElement) {
                    ipElement.textContent = data.ip;
                }
            } catch (error) {
                console.error('Error getting IP:', error);
                const ipElement = document.getElementById('userIp');
                if (ipElement) {
                    ipElement.textContent = 'Unable to detect';
                }
            }
        }

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Gooey Navigation
            const gooeyNavContainer = document.getElementById('gooeyNav');
            if (gooeyNavContainer) {
                // Set active index to 1 for Dashboard (second item)
                const gooeyNav = new GooeyNav(gooeyNavContainer, {
                    animationTime: 600,
                    particleCount: 15,
                    particleDistances: [90, 10],
                    particleR: 100,
                    timeVariance: 300
                });
                gooeyNav.activeIndex = 1; // Dashboard is index 1
            }

            // Load latest analysis on page load
            loadLatestAnalysis();

            // Get and display user IP address
            displayUserIP();

            // Animate counters on load
            const statValues = document.querySelectorAll('.stat-value');
            statValues.forEach(stat => {
                const finalValue = stat.textContent;
                if (!isNaN(parseInt(finalValue))) {
                    let currentValue = 0;
                    const increment = parseInt(finalValue) / 50;
                    const timer = setInterval(() => {
                        currentValue += increment;
                        if (currentValue >= parseInt(finalValue)) {
                            currentValue = parseInt(finalValue);
                            clearInterval(timer);
                        }
                        stat.textContent = Math.floor(currentValue).toLocaleString();
                    }, 30);
                }
            });
        });

        // Letter Glitch Effect
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        
        const glitchColors = ['#2b4539', '#61dca3', '#61b3dc'];
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$&*()-_+=/[]{};:<>.,0123456789';
        const lettersAndSymbols = Array.from(characters);
        
        const fontSize = 16;
        const charWidth = 10;
        const charHeight = 20;
        const glitchSpeed = 50;
        
        let letters = [];
        let grid = { columns: 0, rows: 0 };
        let lastGlitchTime = Date.now();
        let animationId;
        
        const getRandomChar = () => lettersAndSymbols[Math.floor(Math.random() * lettersAndSymbols.length)];
        const getRandomColor = () => glitchColors[Math.floor(Math.random() * glitchColors.length)];
        
        const hexToRgb = hex => {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        };
        
        const interpolateColor = (start, end, factor) => {
            const result = {
                r: Math.round(start.r + (end.r - start.r) * factor),
                g: Math.round(start.g + (end.g - start.g) * factor),
                b: Math.round(start.b + (end.b - start.b) * factor)
            };
            return `rgb(${result.r}, ${result.g}, ${result.b})`;
        };
        
        const calculateGrid = (width, height) => {
            const columns = Math.ceil(width / charWidth);
            const rows = Math.ceil(height / charHeight);
            return { columns, rows };
        };
        
        const initializeLetters = (columns, rows) => {
            grid = { columns, rows };
            const totalLetters = columns * rows;
            letters = Array.from({ length: totalLetters }, () => ({
                char: getRandomChar(),
                color: getRandomColor(),
                targetColor: getRandomColor(),
                colorProgress: 1
            }));
        };
        
        const resizeCanvas = () => {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            const { columns, rows } = calculateGrid(window.innerWidth, window.innerHeight);
            initializeLetters(columns, rows);
            drawLetters();
        };
        
        const drawLetters = () => {
            if (!ctx || letters.length === 0) return;
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            ctx.font = `${fontSize}px monospace`;
            ctx.textBaseline = 'top';
            
            letters.forEach((letter, index) => {
                const x = (index % grid.columns) * charWidth;
                const y = Math.floor(index / grid.columns) * charHeight;
                ctx.fillStyle = letter.color;
                ctx.fillText(letter.char, x, y);
            });
        };
        
        const updateLetters = () => {
            if (!letters || letters.length === 0) return;
            const updateCount = Math.max(1, Math.floor(letters.length * 0.05));
            
            for (let i = 0; i < updateCount; i++) {
                const index = Math.floor(Math.random() * letters.length);
                if (!letters[index]) continue;
                
                letters[index].char = getRandomChar();
                letters[index].targetColor = getRandomColor();
                letters[index].colorProgress = 0;
            }
        };
        
        const handleSmoothTransitions = () => {
            let needsRedraw = false;
            letters.forEach(letter => {
                if (letter.colorProgress < 1) {
                    letter.colorProgress += 0.05;
                    if (letter.colorProgress > 1) letter.colorProgress = 1;
                    
                    const startRgb = hexToRgb(letter.color);
                    const endRgb = hexToRgb(letter.targetColor);
                    if (startRgb && endRgb) {
                        letter.color = interpolateColor(startRgb, endRgb, letter.colorProgress);
                        needsRedraw = true;
                    }
                }
            });
            
            if (needsRedraw) {
                drawLetters();
            }
        };
        
        const animate = () => {
            const now = Date.now();
            if (now - lastGlitchTime >= glitchSpeed) {
                updateLetters();
                drawLetters();
                lastGlitchTime = now;
            }
            
            handleSmoothTransitions();
            animationId = requestAnimationFrame(animate);
        };
        
        // Initialize glitch effect
        resizeCanvas();
        animate();
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                cancelAnimationFrame(animationId);
                resizeCanvas();
                animate();
            }, 100);
        });
    </script>
</body>
</html> 